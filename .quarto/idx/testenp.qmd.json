{"title":"Testes Não Paramétricos","markdown":{"yaml":{"title":"Testes Não Paramétricos"},"headingText":"os dados não são normais, o que eu faço?","containsRefs":false,"markdown":"\n\nQuando os dados não seguem uma distribuição normal, ou quando não podemos assumir variâncias homogêneas entre os grupos, é necessário recorrer a testes não paramétricos. Esses testes não dependem de pressupostos fortes sobre a distribuição dos dados, o que os torna uma escolha ideal para situações em que as condições para análises paramétricas, como a ANOVA, não são atendidas.\n\nPacotes que ainda não foram usados neste site e precisam ser instalados\n\n```{r, echo=TRUE, eval=FALSE}\ninstall.packages(\"agricolae\") \ninstall.packages(\"lme4\") \ninstall.packages(\"performance\") \ninstall.packages(\"report\")\n\n\n```\n\n\nPrimeiro, precisamos verificar se os dados seguem uma distribuição normal. Se não, podemos usar transformações ou recorrer a testes não paramétricos. Vamos ver como verificar a normalidade e como proceder:\n\n```{r, message=FALSE, warning=FALSE}\n# Carregando os dados do pacote InsectSprays\nlibrary(agricolae)\nlibrary(ggplot2)\ninsetos <- InsectSprays\nView(insetos)\n\n# Visualizando os dados com um gráfico de boxplot e jitter\ninsetos |> \n  ggplot(aes(spray, count)) +\n  geom_boxplot(outlier.color = NA) +   # Removendo outliers no boxplot\n  geom_jitter(width = 0.1)             # Adicionando dispersão nos pontos\n\n# Ajustando um modelo linear para verificar o efeito do tipo de spray no número de insetos mortos\nm2 <- lm(count ~ spray, data = insetos) \n\n# Verificando os resíduos do modelo\nhist(residuals(m2))  # Histograma dos resíduos\nshapiro.test(residuals(m2))  # Teste de normalidade de Shapiro-Wilk\n\n# Teste de Bartlett para verificar se as variâncias são homogêneas\nbartlett.test(count ~ spray, data = insetos)\n\n# Verificando visualmente se os resíduos seguem uma distribuição normal\nqqnorm(residuals(m2))  # Q-Q plot para os resíduos\nqqline(residuals(m2))   # Linha de referência no Q-Q plot\n\n\n```\n\nSe os dados não atenderem aos pressupostos de normalidade ou homocedasticidade, podemos aplicar transformações nos dados ou usar testes não paramétricos.\n\n### Alternativa 1 - Transformação dos Dados\n\nUma opção para lidar com dados não normais é transformar os dados. Uma transformação comum é a raiz quadrada, que pode ajudar a normalizar a distribuição dos dados.\n\n```{r, message=FALSE, warning=FALSE}\nlibrary(report)\nlibrary(emmeans)\nlibrary(multcomp)\n# Aplicando transformação de raiz quadrada nos dados\nm3 <- lm(sqrt(count) ~ spray, data = insetos)\n\n# Teste de normalidade nos resíduos após transformação\nshapiro.test(residuals(m3))\nhist(residuals(m3))   # Visualização da distribuição dos resíduos\nqqnorm(residuals(m3))  # Q-Q plot dos resíduos\nqqline(residuals(m3))   # Linha de referência no Q-Q plot\n\n# Teste de Bartlett para homogeneidade de variâncias após transformação\nbartlett.test(sqrt(count) ~ spray, data = insetos)\n\n# Realizando ANOVA no modelo transformado\nanova(m3)\n\n# Relatório do modelo ajustado\nreport(m3)\n\n# Estimando médias ajustadas e destransformando os resultados\nm33 <- emmeans(m3, ~ spray, type = \"response\")  # Desfazendo a transformação\nplot(m33)\ncld(m33)  # Comparações de médias ajustadas entre os grupos\n\n```\n\n### Alternativa 2 - Testes Não Paramétricos\n\nQuando os dados não podem ser transformados para normalizar sua distribuição, a solução é recorrer a testes não paramétricos. Um dos testes mais comuns para comparação de medianas entre dois ou mais grupos é o Teste de Kruskal-Wallis.\n\n```{r, message=FALSE, warning=FALSE}\n# Teste de Kruskal-Wallis para comparar os grupos\nkruskal.test(count ~ spray, data = insetos)\n\n# Utilizando o pacote agricolae para comparações pós-hoc entre os grupos\nlibrary(agricolae)\nkruskal(insetos$count, insetos$spray, group = TRUE, console = TRUE)\n\n```\n\n*O teste de Kruskal-Wallis é o equivalente não paramétrico da ANOVA e é utilizado quando os dados são ordinais ou não atendem às suposições de normalidade. Ele verifica se existem diferenças significativas entre as medianas dos grupos. Após esse teste, se for detectada diferença, realizamos comparações múltiplas para entender quais grupos são significativamente diferentes.*\n\n### Alternativa 3 - Modelos Lineares Generalizados (GLM)\n\nSe preferirmos continuar com uma abordagem paramétrica, mas nossos dados não atenderem às suposições da ANOVA, podemos usar Modelos Lineares Generalizados (GLM). Por exemplo, para dados de contagem, podemos usar a distribuição de Poisson.\n\n```{r, message=FALSE, warning=FALSE}\nlibrary(DHARMa)\n# Ajustando um modelo de Poisson para dados de contagem\nm2.3 <- glm(count ~ spray, data = insetos, family = poisson)\n\n# Exibindo a ANOVA para o modelo de Poisson\nanova(m2.3)\n\n# Usando o pacote car para uma ANOVA mais detalhada\nlibrary(car)\nAnova(m2.3)\n\n# Verificando os resíduos do modelo de Poisson\nplot(simulateResiduals(m2.3))\n\n# Estimativas de médias ajustadas para o modelo de Poisson\nmedias_m2.3 <- emmeans(m2.3, ~ spray, type = \"response\")\nmedias_m2.3\ncld(medias_m2.3)\n\n```\n\nO GLM com distribuição de Poisson é adequado para dados de contagem, como o número de insetos mortos por tipo de spray. Esse modelo é mais flexível que a ANOVA e pode lidar com dados de contagem de forma eficiente.\n\n## Box-Cox\n\n### O que é o Box-Cox?\n\nO **Box-Cox** é uma técnica de transformação de dados que busca estabilizar a variância e transformar os dados para aproximá-los de uma distribuição normal. Ele permite que você teste diferentes valores de lambda para encontrar a transformação ideal.\n\n```{r, message=FALSE, warning=FALSE}\n# Aplicando o Box-Cox para encontrar o melhor valor de lambda\n\nboxcox(lm(insetos$count+0.1 ~1))  # Adicionando 0.1 para garantir que os valores são positivos\nb <- boxcox(lm(insetos$count+0.1 ~1))\n\n# Encontrando o valor de lambda que maximiza a função de verossimilhança\nlambda <- b$x[which.max(b$y)] \nlambda\n\n# Transformando os dados com o valor de lambda obtido\nlibrary(tidyverse) \ninsetos <- insetos |> \n  mutate(count2 = (count^lambda - 1)/lambda) |> \n  mutate(count3 = (sqrt(count))) \n\n# Visualizando o histograma da variável transformada\nhist(insetos$count2)\n\n\n```\n","srcMarkdownNoYaml":"\n\nQuando os dados não seguem uma distribuição normal, ou quando não podemos assumir variâncias homogêneas entre os grupos, é necessário recorrer a testes não paramétricos. Esses testes não dependem de pressupostos fortes sobre a distribuição dos dados, o que os torna uma escolha ideal para situações em que as condições para análises paramétricas, como a ANOVA, não são atendidas.\n\nPacotes que ainda não foram usados neste site e precisam ser instalados\n\n```{r, echo=TRUE, eval=FALSE}\ninstall.packages(\"agricolae\") \ninstall.packages(\"lme4\") \ninstall.packages(\"performance\") \ninstall.packages(\"report\")\n\n\n```\n\n### os dados não são normais, o que eu faço?\n\nPrimeiro, precisamos verificar se os dados seguem uma distribuição normal. Se não, podemos usar transformações ou recorrer a testes não paramétricos. Vamos ver como verificar a normalidade e como proceder:\n\n```{r, message=FALSE, warning=FALSE}\n# Carregando os dados do pacote InsectSprays\nlibrary(agricolae)\nlibrary(ggplot2)\ninsetos <- InsectSprays\nView(insetos)\n\n# Visualizando os dados com um gráfico de boxplot e jitter\ninsetos |> \n  ggplot(aes(spray, count)) +\n  geom_boxplot(outlier.color = NA) +   # Removendo outliers no boxplot\n  geom_jitter(width = 0.1)             # Adicionando dispersão nos pontos\n\n# Ajustando um modelo linear para verificar o efeito do tipo de spray no número de insetos mortos\nm2 <- lm(count ~ spray, data = insetos) \n\n# Verificando os resíduos do modelo\nhist(residuals(m2))  # Histograma dos resíduos\nshapiro.test(residuals(m2))  # Teste de normalidade de Shapiro-Wilk\n\n# Teste de Bartlett para verificar se as variâncias são homogêneas\nbartlett.test(count ~ spray, data = insetos)\n\n# Verificando visualmente se os resíduos seguem uma distribuição normal\nqqnorm(residuals(m2))  # Q-Q plot para os resíduos\nqqline(residuals(m2))   # Linha de referência no Q-Q plot\n\n\n```\n\nSe os dados não atenderem aos pressupostos de normalidade ou homocedasticidade, podemos aplicar transformações nos dados ou usar testes não paramétricos.\n\n### Alternativa 1 - Transformação dos Dados\n\nUma opção para lidar com dados não normais é transformar os dados. Uma transformação comum é a raiz quadrada, que pode ajudar a normalizar a distribuição dos dados.\n\n```{r, message=FALSE, warning=FALSE}\nlibrary(report)\nlibrary(emmeans)\nlibrary(multcomp)\n# Aplicando transformação de raiz quadrada nos dados\nm3 <- lm(sqrt(count) ~ spray, data = insetos)\n\n# Teste de normalidade nos resíduos após transformação\nshapiro.test(residuals(m3))\nhist(residuals(m3))   # Visualização da distribuição dos resíduos\nqqnorm(residuals(m3))  # Q-Q plot dos resíduos\nqqline(residuals(m3))   # Linha de referência no Q-Q plot\n\n# Teste de Bartlett para homogeneidade de variâncias após transformação\nbartlett.test(sqrt(count) ~ spray, data = insetos)\n\n# Realizando ANOVA no modelo transformado\nanova(m3)\n\n# Relatório do modelo ajustado\nreport(m3)\n\n# Estimando médias ajustadas e destransformando os resultados\nm33 <- emmeans(m3, ~ spray, type = \"response\")  # Desfazendo a transformação\nplot(m33)\ncld(m33)  # Comparações de médias ajustadas entre os grupos\n\n```\n\n### Alternativa 2 - Testes Não Paramétricos\n\nQuando os dados não podem ser transformados para normalizar sua distribuição, a solução é recorrer a testes não paramétricos. Um dos testes mais comuns para comparação de medianas entre dois ou mais grupos é o Teste de Kruskal-Wallis.\n\n```{r, message=FALSE, warning=FALSE}\n# Teste de Kruskal-Wallis para comparar os grupos\nkruskal.test(count ~ spray, data = insetos)\n\n# Utilizando o pacote agricolae para comparações pós-hoc entre os grupos\nlibrary(agricolae)\nkruskal(insetos$count, insetos$spray, group = TRUE, console = TRUE)\n\n```\n\n*O teste de Kruskal-Wallis é o equivalente não paramétrico da ANOVA e é utilizado quando os dados são ordinais ou não atendem às suposições de normalidade. Ele verifica se existem diferenças significativas entre as medianas dos grupos. Após esse teste, se for detectada diferença, realizamos comparações múltiplas para entender quais grupos são significativamente diferentes.*\n\n### Alternativa 3 - Modelos Lineares Generalizados (GLM)\n\nSe preferirmos continuar com uma abordagem paramétrica, mas nossos dados não atenderem às suposições da ANOVA, podemos usar Modelos Lineares Generalizados (GLM). Por exemplo, para dados de contagem, podemos usar a distribuição de Poisson.\n\n```{r, message=FALSE, warning=FALSE}\nlibrary(DHARMa)\n# Ajustando um modelo de Poisson para dados de contagem\nm2.3 <- glm(count ~ spray, data = insetos, family = poisson)\n\n# Exibindo a ANOVA para o modelo de Poisson\nanova(m2.3)\n\n# Usando o pacote car para uma ANOVA mais detalhada\nlibrary(car)\nAnova(m2.3)\n\n# Verificando os resíduos do modelo de Poisson\nplot(simulateResiduals(m2.3))\n\n# Estimativas de médias ajustadas para o modelo de Poisson\nmedias_m2.3 <- emmeans(m2.3, ~ spray, type = \"response\")\nmedias_m2.3\ncld(medias_m2.3)\n\n```\n\nO GLM com distribuição de Poisson é adequado para dados de contagem, como o número de insetos mortos por tipo de spray. Esse modelo é mais flexível que a ANOVA e pode lidar com dados de contagem de forma eficiente.\n\n## Box-Cox\n\n### O que é o Box-Cox?\n\nO **Box-Cox** é uma técnica de transformação de dados que busca estabilizar a variância e transformar os dados para aproximá-los de uma distribuição normal. Ele permite que você teste diferentes valores de lambda para encontrar a transformação ideal.\n\n```{r, message=FALSE, warning=FALSE}\n# Aplicando o Box-Cox para encontrar o melhor valor de lambda\n\nboxcox(lm(insetos$count+0.1 ~1))  # Adicionando 0.1 para garantir que os valores são positivos\nb <- boxcox(lm(insetos$count+0.1 ~1))\n\n# Encontrando o valor de lambda que maximiza a função de verossimilhança\nlambda <- b$x[which.max(b$y)] \nlambda\n\n# Transformando os dados com o valor de lambda obtido\nlibrary(tidyverse) \ninsetos <- insetos |> \n  mutate(count2 = (count^lambda - 1)/lambda) |> \n  mutate(count3 = (sqrt(count))) \n\n# Visualizando o histograma da variável transformada\nhist(insetos$count2)\n\n\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"testenp.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","editor":"visual","theme":"journal","title":"Testes Não Paramétricos"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}